## flatbuffer
```
table RpcToServer {
    mode:RPCMode;
    isReliable:bool;
    sync_id:int;
    func_name:string;
    param_data:[ubyte];
    param_types:[ParameterType];
    param_size:[ushort];
}
```

### compiler
生成对应的RpcToServer.go和RpcToServer.cs

## Go 
```go
room.RegisterRPC("VerifyPenalty", this.RPCVerifyPenalty)
```

## C#
```c#
RPCView.RPCToServer("VerifyPenalty", data.Write());
```

### RPCView


## Go-leaf-RegisterChanRPC 「chanrpc 注册」
```go
// room/module.go
m.RegisterChanRPC("NewBattle", createNewBattle)

// 本质上调用的是leaf/module/skeleton 的 RegisterChanRPC 方法
type Skeleton struct {
	GoLen              int
	TimerDispatcherLen int
	AsynCallLen        int
	ChanRPCServer      *chanrpc.Server
	g                  *g.Go
	dispatcher         *timer.Dispatcher
	client             *chanrpc.Client
	server             *chanrpc.Server
	commandServer      *chanrpc.Server
}

func (s *Skeleton) RegisterChanRPC(id interface{}, f interface{}) {
	if s.ChanRPCServer == nil {
		panic("invalid ChanRPCServer")
	}

	s.server.Register(id, f)
}

// s.server 实质上是 *chanrpc.Server，着重看下leaf/chanrpc/chanrpc
type Server struct {
	// id -> function
	//
	// function:
	// func(args []interface{})
	// func(args []interface{}) interface{}
	// func(args []interface{}) []interface{}
	functions map[interface{}]interface{}
	ChanCall  chan *CallInfo
	isClosed  bool
}

// you must call the function before calling Open and Go
func (s *Server) Register(id interface{}, f interface{}) {
	switch f.(type) {
	case func([]interface{}):
	case func([]interface{}) interface{}:
	case func([]interface{}) []interface{}:
	default:
		panic(fmt.Sprintf("function id %v: definition of function is invalid", id))
	}

	if _, ok := s.functions[id]; ok {
		panic(fmt.Sprintf("function id %v: already registered", id))
	}

	s.functions[id] = f
}
```

上边完成了room module 方法的注册逻辑 *chanrpc.Server, 接下来看gate module中的分发
```go
msg.ClientProcessor.SetRouter(msg.RpcToServer, cmn.RoomChanRPC)

// msg.RpcToServer => RpcToServer uint16 = iota
// cmn.RoomChanRPC => var RoomChanRPC *chanrpc.Server

// 需要搞明白msg.ClientProcessor.SetRouter：
// leaf/network/raw.go
type Processor struct {
	littleEndian bool
	msgInfo      map[uint16]*MsgInfo
}

type MsgInfo struct {
	msgRouter  *chanrpc.Server
	msgHandler MsgHandler
}

func (p *Processor) SetRouter(msgID uint16, msgRouter *chanrpc.Server) {
	if _, ok := p.msgInfo[msgID]; ok {
		log.Fatal("message %s already registered", msgID)
	}
	p.msgInfo[msgID] = &MsgInfo{}
	p.msgInfo[msgID].msgRouter = msgRouter
}

```

## room 中的 room.RegisterRPC
```go
func (this *PenaltyController) Init(room *Room) {
	this.room = room
	room.RegisterRPC("VerifyPenalty", this.RPCVerifyPenalty)
}
```

### room.RegisterRPC 与 m.RegisterChanRPC 的区别
```go
type Room struct {
	playersMutex sync.RWMutex
	Players      []*Player
    rpcHandlers  map[string]roomRPCHandler
}

func (room *Room) RegisterRPC(name string, rpcHandler roomRPCHandler) {
	if _, yes := room.rpcHandlers[name]; yes {
		room.Error("a rpc function %v already registered", name)
		return
	}
	room.rpcHandlers[name] = rpcHandler
}
```
可见RegisterRPC直接把方法放到了Room.rpcHandlers上，而m.RegisterChanRPC是skeleton的*chanrpc.Server上边


## 接收消息
### leaf gate/module
```go
type Gate struct {
	MaxConnNum      int
	PendingWriteNum int
	MaxMsgLen       uint32
	AgentChanRPC    *chanrpc.Server
	WSAgentChanRPC  *chanrpc.Server
	TCPAgentChanRPC *chanrpc.Server

	UDPProcessor network.Processor
	TCPProcessor network.Processor
	WSProcessor  network.Processor

	// udp
	UDPAddr string

	// tcp
	TCPAddr string

	// websocket
	WSAddr      string
	HTTPTimeout time.Duration
}
```
需要分析TCPProcessor network.Processor

"git.ftang.cn/library/leaf.git/network"
