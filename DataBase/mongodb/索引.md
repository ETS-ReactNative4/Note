> Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan, i.e. scan every document in a collection, to select those documents that match the query statement. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect.

https://docs.mongodb.com/manual/indexes/

## 索引的意义及注意问题
创建索引
```
db.products.createIndex(
  { item: 1, quantity: -1 } ,
  { name: "query for inventory" }
)
```
You can view index names using the db.collection.getIndexes() method. You cannot rename an index once created. Instead, you must drop and re-create the index with a new name.

查询collection的索引情况
```
> db.books.getIndexes()
[
  {
    "v" : 2,
    "key" : {
      "_id" : 1
    },
    "name" : "_id_",
    "ns" : "students.books"
  }
]
```
给常用的查询创建索引，可以大幅提高查询速度，虽然会影响写入速度，但是数据量很大的情况下是值得的
创建索引要注意的问题：
在插入数据之前就创建，否则在已有大量数据的时候创建索引会需要很长的时间，损害数据库的性能

## 索引的分类：
**单键索引，复合索引, 多键索引，全文索引, 地理位置索引, 哈希索引**

## 创建索引：
https://mongoing.com/archives/2797

db.collection.ensureIndex(keys, options)
注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，
之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。

keys：
For an ascending index on a field, specify a value of 1; for descending index, specify a value of -1.

**对于字段上的升序索引，指定值为1;对于降序索引，指定值为-1。**

### 单字段索引 （Single Field Index）
```
db.person.createIndex( {age: 1} ) 
```

### 复合索引 (Compound Index)
```
db.person.createIndex( {age: 1, name: 1} ) 

上述索引对应的数据组织类似下表，与{age: 1}索引不同的时，当age字段相同时，在根据name字段进行排序，所以pos5对应的文档排在pos3之前。

age,name	位置信息
18,adam	pos5
18,jack	pos3
19,jack	pos1
20,rose	pos2
21,tony	pos4

复合索引能满足的查询场景比单字段索引更丰富，不光能满足多个字段组合起来的查询，比如db.person.find( {age： 18， name: "jack"} )，
也能满足所以能匹配符合索引前缀的查询，这里{age: 1}即为{age: 1, name: 1}的前缀，所以类似db.person.find( {age： 18} )的查询也能通过该索引来加速；
但db.person.find( {name: "jack"} )则无法使用该复合索引。如果经常需要根据『name字段』以及『name和age字段组合』来查询，则应该创建如下的复合索引

db.person.createIndex( {name: 1, age: 1} ) 

除了查询的需求能够影响索引的顺序，字段的值分布也是一个重要的考量因素，即使person集合所有的查询都是『name和age字段组合』（指定特定的name和age），字段的顺序也是有影响的。

age字段的取值很有限，即拥有相同age字段的文档会有很多；而name字段的取值则丰富很多，拥有相同name字段的文档很少；显然先按name字段查找，再在相同name的文档里查找age字段更为高效。

使用索引
> db.students.find({name: "fuck", age: 18})

```

### Multikey Index
MongoDB为数组的每个元素创建单独的索引项。这些多键索引允许查询通过匹配数组的一个或多个元素来选择包含数组的文档。MongoDB自动决定是否创建一个多键索引，如果索引字段包含数组值;您不需要显式地指定多键类型。

### MongoDB Text Indexes（全文索引）一个mongodb数据集合只能创建一个全文索引
https://docs.mongodb.com/manual/text-search/index.html

不支持中文

Create a collection stores with the following documents:
```
db.stores.insert(
   [
     { _id: 1, name: "Java Hut", description: "Coffee and cakes" },
     { _id: 2, name: "Burger Buns", description: "Gourmet hamburgers" },
     { _id: 3, name: "Coffee Shop", description: "Just coffee" },
     { _id: 4, name: "Clothes Clothes Clothes", description: "Discount clothing" },
     { _id: 5, name: "Java Shopping", description: "Indonesian goods" }
   ]
)
```
为 name description 穿件索引
```
db.stores.createIndex( { name: "text", description: "text" } )
```

For example, you could use the following query to find all stores containing any terms from the list “coffee”, “shop”, and “java”:
```
db.stores.find( { $text: { $search: "java coffee shop" } } )
```


### 地理位置索引：（2D平面地理位置索引，2Dsphere 索引）
```
> db.location.ensureIndex({"w": "2d"})
{
  "createdCollectionAutomatically" : true,
  "numIndexesBefore" : 1,
  "numIndexesAfter" : 2,
  "ok" : 1
}
```
位置的表示方式 经纬度[经度, 纬度]
取值范围 经度[-180, 180]  纬度[-90, 90]
查询方式：
$near 查询距离某个点最近的点
$geoWithin 查询某个形状内的点

```
> db.location.find({"w": {$near: [39, 29]}})
{ "_id" : ObjectId("5bb80aa837c243e75d95e14f"), "w" : [ 40, 30 ] }
{ "_id" : ObjectId("5bb80a8d37c243e75d95e14d"), "w" : [ 10, 20 ] }
{ "_id" : ObjectId("5bb80a9a37c243e75d95e14e"), "w" : [ 100, 30 ] }
{ "_id" : ObjectId("5bb80ab337c243e75d95e150"), "w" : [ 140, 30 ] }
会默认返回100条数据

> db.location.find({"w": {$near: [39, 29], $maxDistance: 5}})
{ "_id" : ObjectId("5bb80aa837c243e75d95e14f"), "w" : [ 40, 30 ] }
```
[Create a collection places with the following documents:](https://docs.mongodb.com/manual/geospatial-queries/)

### Multikey Index
To support hash based sharding, MongoDB provides a hashed index type, which indexes the hash of the value of a field. These indexes have a more random distribution of values along their range, but only support equality matches and cannot support range-based queries.
为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内具有更随机的值分布，但只支持相等匹配，而不支持基于范围的查询。

## 删除索引
```
db.collection.dropIndex("name")
```

## 索引构建情况分析
1. mongostat工具介绍
2. profile集合介绍
3. 日志介绍
4. explain分析

```
./bin/mongostat -h 127.0.0.1:12345
应该关心的性能参数 qr|qw 读队列和写队列 数值如果较高 说明性能有问题
如果数据库数据量较大 idx miss 未使用索引的值较高 可能会导致qr较高
➜  bin mongostat -h 127.0.0.1:27017
insert query update delete getmore command dirty used flushes vsize   res qrw arw net_in net_out conn                time
    *0    *0     *0     *0       0     2|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   160b   43.4k    2 Oct  6 09:52:22.794
    *0    *0     *0     *0       0     2|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   158b   42.6k    2 Oct  6 09:52:23.794
    *0    *0     *0     *0       0     1|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   157b   42.4k    2 Oct  6 09:52:24.798
    *0    *0     *0     *0       0     2|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   158b   42.8k    2 Oct  6 09:52:25.795
    *0    *0     *0     *0       0     2|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   158b   42.6k    2 Oct  6 09:52:26.794
    *0    *0     *0     *0       0     1|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   157b   42.5k    2 Oct  6 09:52:27.797
    *0    *0     *0     *0       0     2|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   158b   42.8k    2 Oct  6 09:52:28.792
    *0    *0     *0     *0       0     1|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   157b   42.4k    2 Oct  6 09:52:29.797
    *0    *0     *0     *0       0     2|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   158b   42.8k    2 Oct  6 09:52:30.793
    *0    *0     *0     *0       0     1|0  0.0% 0.0%       0 3.13G 11.0M 0|0 0|0   157b   42.4k    2 Oct  6 09:52:31.797
```

explain
```
> db.location.find({"w": [10, 20]}).explain()
```



