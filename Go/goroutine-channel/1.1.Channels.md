> Channels are the pipes that connect concurrent goroutines. You can send values into channels from one goroutine and receive those values into another goroutine.
> Channels 是连接并发的 goroutines 的管道，一个 goroutine 的值可以发送到 channels 中并由其他 goroutine 接收。

## Create a new channel with make(chan val-type) 使用make来创建channel
```go
package main

import "fmt"

func main() {

	messages := make(chan string)

	go func() { messages <- "ping" }() // 自执行

	msg := <- messages
	fmt.Println(msg)
}
// ping
```

## 数据类型为string的chan
```go
package main

import (
	"fmt"
	"time"
)

func sendData(ch chan string) {
	ch <- "Washington"
	ch <- "Tripoli"
	ch <- "London"
	ch <- "Beijing"
	ch <- "Tokyo"
}

func getData(ch chan string) {
	var input string
	// time.Sleep(2e9)
	for {
		input = <-ch
		fmt.Printf("%s ", input)
	}
}

func main() {
	ch := make(chan string)

	go sendData(ch)
	go getData(ch)

	time.Sleep(1e9)
}
/**
输出：
Washington Tripoli London Beijing tokyo
**/
```

## 数据类型为struct的chan
```go
type Server struct {
	// id -> function
	functions map[interface{}]interface{}
	ChanCall  chan *CallInfo
	isClosed  bool
}

type CallInfo struct {
	f       interface{}
	args    []interface{}
	chanRet chan *RetInfo
	cb      interface{}
}
```
上面Server中的ChanCall  chan *CallInfo 就是struct类型

使用：
```go
// goroutine safe
func (s *Server) Go(id interface{}, args ...interface{}) {
	if s.isClosed {
		return
	}

	f := s.functions[id]
	if f == nil {
		return
	}

	defer recover()

	s.ChanCall <- &CallInfo{
		f:    f,
		args: args,
	}
}
```
向通道s.ChanCall发送CallInfo类型的数据

### channel 的关闭和广播
1. 向关闭的channel中发送数据，会导致panic
2. v,ok <- ch;  ok 为bool值，true表示正常接收，false表示通道关闭
3. 所有的channel接受者都会在channel关闭时立即从阻塞等待中返回且ok值为false，这个广播机制经常被利用向多个订阅者发送退出信号

## Context
1. 根 Context：通过context.Background() 创建
2. 子 Context：context.WithCancel(parentContext) 创建
3. ctx, cancel := context.WithCancel(context.Background())
4. 当前Context被取消时，基于它的子context都会被取消
5. 接受取消通知 <- ctx.Done()

```go
package main

import (
	"fmt"
	"time"
	"context"
)

func isCancelled(ctx context.Context) bool {
	select {
		case <- ctx.Done():
			return true
		default:
			return false
	}
}

func TestCancel() {
	ctx, cancel := context.WithCancel(context.Background())
	for i := 0; i < 5; i++ {
		go func(i int, ctx context.Context) {
			for {
				if isCancelled(ctx) {
					break
				}
				time.Sleep(time.Millisecond * 5)
			}
			fmt.Println(i, "Cancelled")
		}(i, ctx)
	}
	cancel()
	time.Sleep(time.Second * 1)
}

func main() {
	TestCancel()
}
// ➜  Test go run cancel.go
// 1 Cancelled
// 2 Cancelled
// 3 Cancelled
// 4 Cancelled
// 0 Cancelled
```