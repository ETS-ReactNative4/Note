> JavaScript 语言对异步编程的实现，就是回调函数。
```
fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});
```

> Promise
允许将回调函数的横向加载，改成纵向加载。Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。
Promise就是为了解决这个问题而提出的
```
var readFile = require('fs-readfile-promise');

readFile(fileA)
.then(function(data){
  console.log(data.toString());
})
.then(function(){
  return readFile(fileB);
})
.then(function(data){
  console.log(data.toString());
})
.catch(function(err) {
  console.log(err);
});
```

### Promise.resolve
```
var taskName = "task 1"
asyncTask(taskName).then(function (value) {
    console.log(value);
}).catch(function (error) {
    console.error(error);
});
function asyncTask(name){
    return Promise.resolve(name).then(function(value){
        return "Done! "+ value;
    });
}

//Done! task 1
```
再如：
```
let p = new Promise((resolve, reject) => {
    setTimeout(()=>{
      Math.random()>0.5 ? resolve('success') : 
      reject('fail');
    },2e3)
});
//2*10的3次方


console.log(p);

p.then((result)=>{
    console.log(result);
},(err)=>{
    console.log(err);
})
```

### Promise.all
```
var p1 = Promise.resolve(1),
    p2 = Promise.resolve(2),
    p3 = Promise.resolve(3);
Promise.all([p1, p2, p3]).then(function (results) {
    console.log(results);  // [1, 2, 3]
});
```

## 使用Q控制流程
