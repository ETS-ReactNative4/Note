> 如何优雅的创建nodejs共享常量
https://blog.csdn.net/wp270280522/article/details/49635581

1. 用global来保存常量
```
// const.js
global.MY_CONST= 'global const';

// main.js
require('./const');
console.log(global.MY_CONST);
global.MY_CONST = 'changed global const';
console.log(global.MY_CONST);
```
➜  express git:(master) ✗ node main
global const
changed global const

但是设计原则上来讲，应该将内容封装到文件内，通过exports导出。 
而且，这种方式并不能定义常量

2. 直接export一个包含常量的对象
```
// const.js
const obj = {
    MY_CONST:'my const'
}

module.exports = obj;
```
这种方式有同样的问题，const并不能定义一个属性无法修改的对象，MY_CONST依然是可以修改的

3. 用Object.defineProperty来定义常量
上面的方法试图定义一个const对象，但这是不可能的。但是我们可以通过配置将对象属性的设定为不可修改的

```
// const.js
Object.defineProperty(exports, "PI", {
    value:        3.14,
    enumerable:   true,
    writable:     false,
    configurable: false
});

writable和configurable默认是false，所以可以简化一下
Object.defineProperty(exports, "PI", {
    value:3.14,
    enumerable:true
});


更好的方式，如果你不想为每一个属性都手写配置的话：
function define(name, value) {
    Object.defineProperty(exports, name, {
        value:      value,
        enumerable: true
    });
}

define("PI", 3.14);
```

4. 通过 Object.freeze 来固定属性值
```
// const.js
module.exports = Object.freeze({
    MY_CONSTANT: 'some value',
    ANOTHER_CONSTANT: 'another value'
});
```
The Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.











