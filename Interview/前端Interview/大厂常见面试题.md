## 盒子模型
[详细](../../Front-End/CSS/box%20model.md)

浏览器渲染会根据CSS的盒子模型渲染页面上的元素，每个box由4个部分构成，分别为它的 margin、border、padding、content
```
.box {
	box-sizing: content-box;
} 
```
content-box  是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。

border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。内容区的实际宽度是width减去(border + padding)的值, border-box不包含margin.

## DOCTYPE
[detail](../../Front-End/HTML/DOCTYPE.md)

## 定位(布局)
position: absolute,relative,fixed
float
flex 实现下面布局：
![pic](https://upload-images.jianshu.io/upload_images/14735639-b5c4e9c45bd237cb.png?imageMogr2/auto-orient/strip|imageView2/2/w/132/format/webp)

### rem适配怎么设置0.01rem =1px

## 动画
[animation](../../Front-End/CSS/animation/animation.html)
```css
@keyframes _rqfzup {
    0% {
        transform: scale(0);
        opacity: 1;
    }

    100% {
        transform: scale(0.5);
        opacity: 0;
    }
}
```

## 基本数据类型
[detail](../Node.js/JS-quiz/0.JavaScript基本数据类型.md)

## 浏览器解析CSS的两种模式：标准模式(strict mode)和怪异模式(quirks mode)
标准模式：浏览器按W3C标准解析执行代码；

怪异模式：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以称之为怪异模式。
[detail](../../Front-End/CSS/css-标准模式和怪异模式.md)

## MVVM 前端框架和 传统前端的区别
传统页面开发：面临的问题就是页面结构的重复，当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，
1. 页面相似代码无法复用 Header, Nav, Footer
2. 页面之间的数据共享非常吃力，需要强制更新dom, 效率低下

因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。

简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。

## Virtual DOM
React 和 Vue 有许多相似之处，它们都有：
1. 使用 Virtual DOM
2. 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。

JSX vs Templates
在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。

对于很多习惯了 HTML 的开发者来说，模板比起 JSX 读写起来更自然。这里当然有主观偏好的成分，但如果这种区别会导致开发效率的提升，那么它就有客观的价值存在。

Vue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神 (比如 Flux、Redux)
Vue 更进一步地采用了这种模式 (Vuex)

https://www.jianshu.com/p/6f31a075a9b5
## bootstrap实现栅格话布局原理
栅格化列的种类,一行根据百分比分为12列
```css
.col-xs-* 针对超小屏幕 手机（<768px）
.col-sm-* 小屏幕 平板 (≥768px)
.col-md-* 中等屏幕 桌面显示器 (≥992px)(栅格参数)
.col-lg-* 针对特大的（≥1200px）
```

### 移动端适配方案
通过媒体查询根据不同的屏幕适配对应的栅格化样式，添加对应的类，比如
```css
/*超小设备（手机：小于768px）*/
@media(max-width:768px){
  .col-xs-1{ width: 8.33333333%;}
  .col-xs-2{ width: 16.66666667%;}
  .col-xs-3{ width: 25%;}
  .col-xs-4{ width: 33.33333333%;}
  .col-xs-5{ width: 41.66666667%;}
  .col-xs-6{ width: 50%;}
  .col-xs-7{ width: 58.33333333%;}
  .col-xs-8{ width: 66.66666667%;}
  .col-xs-9{ width: 75%;}
  .col-xs-10{ width: 83.33333333%;}
  .col-xs-11{ width: 91.66666667%;}
  .col-xs-12{ width: 100%;}
}

/*小型设备 （平板电脑：768px起）0*/
@media(min-width:768px){
  .col-sm-1{ width: 8.33333333%;}
  ...
}
 
/*中型设备（台式电脑：992px起）*/
@media(min-width:992px){
  .col-md-1{ width: 8.33333333%;}
  ...
}
 
/*大型设备（台式电脑：1200px起）*/
@media(min-width:1200px){
  .col-lg-1{ width: 8.33333333%;}
  ...   
}
```

## webpack了解多少，自己做了哪些配置
### loader和plugins的区别，有没有手写过loader

## react
- his.setState是怎么实现异步的
- 宏任务/微任务
- hook

设计模式的实现，工厂者模式、发布者订阅者模式手写代码说明

## vue 组件 data为什么必须是函数?

### vue 双向绑定
```js
var vm = new Vue({
    data: {
        obj: {
            a: 1
        }
    },
    created: function () {
        console.log(this.obj);
    }
});
```
我们可以看到属性a有两个相对应的get和set方法，为什么会多出这两个方法呢？因为vue是通过Object.defineProperty()来实现数据劫持的。
Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set，如果还不熟悉其用法，[请点击这里阅读更多用法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。

当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。

### 实现Observer Watcher
https://www.cnblogs.com/chenhuichao/p/10818396.html

### vue-router
https://www.cnblogs.com/everlose/p/12608978.html
https://segmentfault.com/a/1190000018227116
```js
// 源码index.js
export default class VueRouter {
  ...
  constructor (options: RouterOptions = {}) {
    this.app = null
    this.apps = []
    this.options = options
    this.beforeHooks = []
    this.resolveHooks = []
    this.afterHooks = []
    this.matcher = createMatcher(options.routes || [], this)

    let mode = options.mode || 'hash'   // 不选择模式会默认使用hash模式
    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false
    if (this.fallback) {
      mode = 'hash'
    }
    if (!inBrowser) {         // 非浏览器环境默认nodejs环境
      mode = 'abstract'
    }
    this.mode = mode

    switch (mode) { // 根据参数选择三种模式的一种
      case 'history':
        this.history = new HTML5History(this, options.base) // 根据HTML5版History的方法和属性实现的模式
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback) // 利用url中的hash特性实现
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base) // 这种模式原理暂不清楚
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }
  ...
  // 一些api方法，你应该很熟悉，$router.push(...)
  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.push(location, onComplete, onAbort)
  }

  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.replace(location, onComplete, onAbort)
  }

  go (n: number) {
    this.history.go(n)
  }

  back () {
    this.go(-1)
  }

  forward () {
    this.go(1)
  }
  ...
}
```
我们创建的路由都是VueRouter类的实例化，用来管理我们的【key-components-view】，一个key（代码中的path）对应一个组件

vue-router是作为插件加入使用的，通过mixin（混合）来影响每一个Vue实例化，在beforeCreate 钩子的时候就会完成router的初始化

1. 第一种：hashHistory模式 url中#号后面的参数，别名哈希值，关于hash的一些特性
2. 第二种：HTML5History模式


## 函数防抖和节流
防抖和节流严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，处理不当或者放任不管就容易引起浏览器卡死。所以还是很有必要早点掌握的。
### 防抖(debounce)
对于短时间内连续触发的事件（如浏览器scroll,keyup,resize,事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。
```js
function debounce(fn, delay) {
    let timer = null
    return function (args) {
        if (timer) {
            clearTimeout(timer) 
        }
        timer = setTimeout(fn.call(this, args), delay)
    }
}
function ajax(content) {
    console.log('ajax request ' + content)
}
let debounceAjax = debounce(ajax, 400)
inputNormal.addEventListener('keyup', function (e) {
    debounceAjax(e.target.value)
})
// 连续的输入触发，但是ajax请求只会在最后一次keyup后的400ms被执行,达到的效果是每一次高频事件都会取消前一次的超时调用，使得事件处理程序不会被触发
```
### 节流(throttle)
```js
function throttle (fn, delay) {
    let valid = true
    return function(args) {
        if(!valid) return
        valid = false
        setTimeout(() => {
            fn.call(this, args) 
            valid = true
        }, delay)
    }
}
function sayHi(e) {
    console.log('节流：', e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi,500));
```
总结：
1. 函数防抖：将多次操作合并为一次操作进行，原理是维护一个计时器，后设置的定时器会取代之前的定时器，如果高频事件一直在触发那么回调函数一直不会执行。
2. 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行，有的话直接返回false,没有的话设置延时函数。

区别：函数节流无论事件触发多么频繁，在一定事件内只会执行一次回调；而函数防抖是在高频事件的最后一次触发回调；假设用户滚动页面加载图片的场景，应该使用函数节流来在一定的时间内发出Ajax请求，而不是函数防抖的最后一次滚动才发出请求，还有就是mousedown发射子弹也适合函数节流，每秒只能发出一颗子弹。

## 另外canvas实现一个手动马赛克的效果

## jquery链式调用的实现方式

## 实现一个Array.filter

## 单元测试怎么查看覆盖率的

## 函数式编程
### 柯里化？compose？
[函数式编程](./函数式编程.md)

## 闭包
闭包的实质
AMD ES5没有模块概念的时候怎么实现，CommonJS规范的区别

## seo优化总结
### TDK完善，包括title、description、keywords，前端页面和后台推送都要添加，如下
```html
<meta name="baidu-site-verification" content="TI4ZF9Ar4h" />
<meta name="keywords" content="北京治疗近视眼医院,北京近视眼矫正,北京好的眼科医院,北京朝阳区眼科医院">
<meta name="description" content="北京眼科医院,北京治疗近视眼科医院,北京近视矫正,北京朝阳区眼科医院,北京***医院是北京好的眼科医院,我院采用先进的飞秒手术,国内外专家就诊.治疗近视选择北京眼科.24小时咨询电话****">
```
### 栏目页旁边要加推荐文章，10条左右
文章详情页下面加本栏目的相关文章
旁边加其他栏目的推荐文章

### 每个页面都要加h1 h2内容，h1标题，要惟一；h2其他栏目名

### 首页的图片上，加title，把想加的关键词均匀分布在图片的title上

### sitemap生成
生成sitemap（Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页）生成的链接页面里，内容是网站的静态路径，用于每天百度收录。

## 其他题目
1. 带连接符的字符串转驼峰的方法 （如get-element-by-id）
```js
Promise.race = function(promises){
    return new Promise((resolve,reject) => {
        let i=0;
        while(i<promises.length){
            promises[i].then(res=>{
                resolve(res); //出现第一个被resolve的直接resolve
            }).catch(err=>{
                reject(err); //出现第一个被reject的直接reject
            });
            i++;
        }
    })
}
```
作者：Time_Notes
链接：https://www.jianshu.com/p/023da0766a79
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。