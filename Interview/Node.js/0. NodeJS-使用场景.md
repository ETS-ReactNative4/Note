> Node.js使用事件驱动的架构，许多连接可以并行处理。每一个连接都会触发一个回调,这与今天使用 OS 线程的更常见并发模型形成了对比。
> 基于线程的网络效率相对低下，使用起来非常困难。此外，Node.js 的用户不必担心死锁过程，因为没有锁。Node 中几乎没有函数直接执行 I/O 操作，因此进程从不阻塞。

https://www.codenong.com/34855352/

我知道Node.js使用单线程和事件循环来处理请求，一次只处理一个(非阻塞)。 但是，如何工作，让我们说10,000个并发请求。 事件循环将处理所有请求？ 这不会花太长时间吗？

我无法理解它是如何比多线程Web服务器更快的。 我知道多线程Web服务器的资源(内存，CPU)会更加昂贵，但它不会更快吗？ 我可能错了; 请解释这个单线程如何在大量请求中更快，以及在处理大量请求(例如10,000)时它通常会做什么(在高级别)。

- 多线程网络应用程序处理上述工作负载，如下所示：
```
request ──> spawn thread
							└──> wait for database request
										└──> answer request
request ──> spawn thread
							└──> wait for database request
										└──> answer request
request ──> spawn thread
							└──> wait for database request
										└──> answer request
```
因此，线程花费大部分时间使用0％CPU等待数据库返回数据。在这样做时，他们必须分配一个线程所需的内存，其中包含一个完全独立的程序堆栈，每个线程等。
此外，他们必须启动一个线程虽然不像启动一个完整的进程那么昂贵但仍然不完全廉价。

- 单线程事件循环
每个请求仍将获得与多线程应用程序相同的CPU时间，但我们不需要启动线程。所以我们这样做：
```
request ──> make database request
request ──> make database request
request ──> make database request
database request complete ──> send response
database request complete ──> send response
database request complete ──> send response
```
实际上，这两种方法都返回大致相同延迟的数据，因为它是主导处理的数据库响应时间。

这里的主要优点是我们不需要生成一个新线程，所以我们不需要做很多很多malloc，这会减慢我们的速度。

## [Node.js特性](https://nodejs.dev/learn)
A Node.js app is run in a single process, without creating a new thread for every request. 
Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, 
libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.

常规的Node应用都是以单个进程的形式运行，不会为每一个请求都创建一个线程【哪些编程语言会为每个请求创建线程？】。
Node.js在其标准库中提供了大量的异步的方法来避免js代码在运行时发生阻塞【如果一个线程执行一个回调函数（事件轮询线程）或者任务（工作线程）需要耗费很长时间，我们称之为“阻塞”。 
当一个线程在处理某一个客户端请求时被阻塞了，它就无法处理其它客户端的请求了。】
【这些库都遵循非阻塞的范式】使阻塞行为成为异常而不是常态

When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.

当Node.js执行I/O操作【读取网络请求，存取数据库或者文件系统】，它的处理方式都不会阻塞线程造成CPU等待，它是会等异步操作返回执行结果然后恢复之前的操作。【如何实现？- 回调函数】

Being blocking is the exception, and this is why JavaScript is based so much on callbacks, and more recently on promises and async/await.
JavaScript如果阻塞了那就是出现了异常，这也就是它为什么会基于那么多的回调函数，包括后来出现的promise和async/await【回调函数是如何避免了阻塞？】

This allows Node.js to handle thousands of concurrent connections with a single server without introducing the burden of managing thread concurrency， 
which could be a significant source of bugs
这就允许Node.js单个服务就可以处理大量的并发连接, 而不用考虑用多线程来处理并发【哪些语言在用多线程处理并发？有什么问题？】


[Don't block event loop](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/)

Node.js 有两种类型的线程：一个事件循环线程和 k 个工作线程。 
事件循环负责 JavaScript 回调和非阻塞 I/O，工作线程执行与 C++ 代码对应的、完成异步请求的任务，包括阻塞 I/O 和 CPU 密集型工作。 
这两种类型的线程一次都只能处理一个活动。 如果任意一个回调或任务需要很长时间，则运行它的线程将被 阻塞。 如果你的应用程序发起阻塞的回调或任务，在好的情况下这可能只会导致吞吐量下降（客户端/秒），而在最坏情况下可能会导致完全拒绝服务。

要编写高吞吐量、防 DoS 攻击的 web 服务，您必须确保不管在良性或恶意输入的情况下，您的事件循环线程和您的工作线程都不会阻塞。

请记住，事件循环线程只负责协调客户端的请求，而不是独自执行完所有任务。 对一个复杂的任务，最好把它从事件循环线程转移到工作线程池上。

> 具体event loop如何工作，查看[**libuv**](./libuv.md)

## 主进程中的event loop阻塞
```js
const http = require('http');

const longComputation = () => {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) {
    sum += i;
  };
  return sum;
};

const server = http.createServer();

server.on('request', (req, res) => {
  if (req.url === '/compute') {
    const sum = longComputation();
    return res.end(`Sum is ${sum}`);
  } else {
    res.end('Ok')
  }
});

server.listen(3000);
```
This program has a big problem; when the the /compute endpoint is requested, 
the server will not be able to handle any other requests because the event loop is busy with the long for loop operation.

We first move the whole longComputation function into its own file and make it invoke that function when instructed via a message from the main process:

In a new compute.js file:
```js
const longComputation = () => {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) {
    sum += i;
  };
  return sum;
};

process.on('message', (msg) => {
  const sum = longComputation();
  process.send(sum);
});
```

Now, instead of doing the long operation in the main process event loop,
we can fork the compute.js file and use the messages interface to communicate messages between the server and the forked process.
```js
const http = require('http');
const { fork } = require('child_process');

const server = http.createServer();

server.on('request', (req, res) => {
  if (req.url === '/compute') {
    const compute = fork('compute.js');
    compute.send('start');
    compute.on('message', sum => {
      res.end(`Sum is ${sum}`);
    });
  } else {
    res.end('Ok')
  }
});

server.listen(3000);
```
When a request to /compute happens now with the above code, we simply send a message to the forked process to start executing the long operation. 
The main process’s event loop will not be blocked.

## [不要阻塞你的事件循环（或是工作线程池）](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/)

Node.js 是用很少量的线程来处理大量客户端请求的。 在 Node.js 中，有两种类型的线程：一个事件循环线程（也被称为主循环，主线程，事件线程等）。
另外一个是在工作线程池里的 k 个工作线程（也被称为线程池）。

请记住，事件循环线程只负责协调客户端的请求，而不是独自执行完所有任务。 对一个复杂的任务，最好把它从事件循环线程转移到工作线程池上。

### 阻塞
如果一个线程执行一个回调函数（事件轮询线程）或者任务（工作线程）需要耗费很长时间，我们称之为“阻塞”。 当一个线程在处理某一个客户端请求时被阻塞了，它就无法处理其它客户端的请求了。 这里给出两个不能阻塞事件轮询线程和工作线程的理由：

- 性能：如果你在任意类型的线程上频繁处理繁重的任务，那么你的服务器的 吞吐量（请求/秒）将面临严峻考验。
- 安全性：如果对于特定的输入，你的某种类型的线程可能会被阻塞，那么恶意攻击者可以通过构造类似这样的“恶意输入”，故意让你的线程阻塞，然后使其它客户端请求得不到处理。这就是拒绝服务攻击。


## NodeJS 使用场景

优点：高并发（最重要的优点）、适合 I/O 密集型应用
```
当你说Node.JS可以处理10,000个并发请求时，它们本质上是非阻塞请求，即这些请求主要与数据库查询有关。
```

缺点：
1. 不适合CPU密集型应用（CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），
   将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起）

解决方案：这个不是正确的角度！！！ 这里是要解决CPU密集型的问题，需要把CPU密集型任务从event loop线程拿出去
```
（1）Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口；
（2）开多个进程监听同一个端口，使用cluster模块
（3）线上使用 PM2 管理进程，出现问题自动重启项目
```

可以使用Node.js 的child process,  worker_thread
那么哪种编程语言可以用什么样的方式比较好的处理CPU密集型的情景？



## 各种编程语言处理并发的方式
[What makes the Single Threaded Event Loop Model Efficient?](https://blog.soshace.com/advanced-node-js-a-hands-on-guide-to-event-loop-child-process-and-worker-threads-in-node-js/)

To better understand what problem Node.js solves we should look at the what typical web servers were like before Node.js came into play.

This is how a traditional multi-threaded web application model handles request:

- It maintains a thread pool (a collection of available threads)
- When client request comes in a thread is assigned
- This thread will take care of reading Client requests, processing Client requestS, performing any Blocking IO Operations (if required) and preparing Response.
- This thread is not free until a response is sent back

这种模型最大的缺点就是有大量并发连接的时候线程枯竭，后来的用户需要等待前边用户的线程释放进而获得响应。
Moreover, the server itself start to slow down because of increasing load. There’s also the overhead of context switching between threads and writing applications to optimize threads resource sharing can be painful.

What happens when you run a Node.js Program?
when we run our Node.js app it creates

1. Process 🤖
2. Thread 🧵
3. Event Loop ➰

The single-threaded event loop architecture uses resources efficiently,
it doesn’t need to spin off new threads for every single request.Node.js also delegates blocking tasks to other components as we saw earlier. Since we don’t really care about many threads it makes node.js very lightweight and ideal for microservice-based architecture.
![event loop](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-2-1.jpg)

### Drawbacks of Node’s Single Threaded Model !!!
This is 2020 😄 and we are seeing more and more complicated web applications. What if our application needs to do complex computation, run a machine learning algorithm? Or What if we want to run a complicated crypto algorithm? In this case we have to harness the power of multiple cores to increase performance.

Languages like Java and C# can programmatically initiate threads and harness the power of multiple cores. In Node.js that is not an option as we saw earlier. Node’s way of solving this problem is child_process.
![child](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-3-1.jpg)

In 2018 Node.js introduced worker_thread. This module allows node the ability to have

1. Process
Multiple threads
2. Event Loop per thread
Yes!! You read that right 😄.

![worker](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-4-1.jpg)

As of January 2020 worker_threads are fully supported in the Node LST version 12. I highly recommend reading up the following post if you want to learn more about worker_threads.

[Node.js multithreading](https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/)

### Node.js
["I/O" 主要指由libuv支持的，与系统磁盘和网络之间的交互](https://nodejs.org/zh-cn/docs/guides/blocking-vs-non-blocking/)
libuv - Cross-platform asynchronous I/O 

- Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
- Asynchronous file and file system operations
- IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
- Child processes


### java

### Golang

## Apache 的多线程高并发模式
优点：支持多线程并发

缺点：阻塞


## 附录
### What do the terms “CPU bound” and “I/O bound” mean?:
- CPU Bound means the rate at which process progresses is limited by the speed of the CPU.
A task that performs calculations on a small set of numbers, for example multiplying small matrices, is likely to be CPU bound.
A program is CPU bound if it would go faster if the CPU were faster.

- CPU 密集型意味着处理任务的速度是由CPU的速度限制的，一般是计算型的应用，如果CPU运行速度越快，应用程序越快那就是CPU密集型应用。

- I/O Bound means the rate at which a process progresses is limited by the speed of the I/O subsystem.
A task that processes data from disk, for example, counting the number of lines in a file is likely to be I/O bound.
A program is I/O bound if it would go faster if the I/O subsystem was faster.

- I/O 密集型意味着程序运行速率由I/O子系统的速度限制，从硬盘上读写数据或者计算一个文件的行数属于I/O型操作。

### I/O-bound vs CPU-bound in Node.js
https://bytearcher.com/articles/io-vs-cpu-bound/

Bound implies performance bottleneck 
Bound 意味着性能瓶颈

I/O-bound application waits most of the time for network, filesystem and database.
I/O-bound 型应用消耗大量时间在 网络连接、文件系统、数据库读写。

CPU bound
This kind of application leads to trouble in Node.js. If the application spends too much time performing CPU intensive task all other requests are being held up. 
CPU bound 型应用导致Node.js应用出现问题。如果消耗大量时间用于CPU占用率高的任务，那么所有其他请求将会被挂起。

A typical healthy Node.js server application is I/O bound. That is what Node.js was designed for and handles well using the single-threaded event loop. 
一个健康的Node.js服务应该是I/O密集型的，这也是使用单线程的事件循环模型设计的初衷。




