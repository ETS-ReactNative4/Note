> 作为异步驱动的 JavaScript 运行时，Node.js 被设计成可升级的网络应用。许多连接可以并行处理。每一个连接都会触发一个回调,这与今天使用 OS 线程的更常见并发模型形成了对比。基于线程的网络效率相对低下，使用起来非常困难。此外，Node.js 的用户不必担心死锁过程，因为没有锁。Node 中几乎没有函数直接执行 I/O 操作，因此进程从不阻塞。

## 各种编程语言处理并发的方式
### Node.js
["I/O" 主要指由libuv支持的，与系统磁盘和网络之间的交互](https://nodejs.org/zh-cn/docs/guides/blocking-vs-non-blocking/)
libuv - Cross-platform asynchronous I/O 

- Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
- Asynchronous file and file system operations
- IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
- Child processes

#### event loop
The event loop is the central part of libuv’s functionality. 
It takes care of polling for i/o and scheduling callbacks to be run based on different sources of events.
![Design overview](http://docs.libuv.org/en/v1.x/_images/architecture.png)

http://docs.libuv.org/en/v1.x/design.html

[Async IO on Linux: select, poll, and epoll](https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/)

### java

### Golang


## NodeJS 使用场景

优点：高并发（最重要的优点）、适合 I/O 密集型应用

缺点：
1. 不适合CPU密集型应用（CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起）
2. 只支持单核CPU，不能充分利用CPU
3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃
   
原因：单进程、单线程
解决方案：
```
（1）Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口；
（2）开多个进程监听同一个端口，使用cluster模块
（3）线上使用 PM2 管理进程，出现问题自动重启项目
```


[进程和线程](https://github.com/iicoom/Note/blob/master/Linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/process%20vs%20thread.md)
## 什么是线程?
线程是可以独立运行的最小的 CPU 单位，可以在同一个进程里并发运行，共享该进程下的内存地址空间。

当不同的线程需要占用同一个变量时，根据先到先得的原则，先到的线程在运作时，后来的线程只能在旁边等待，也就是加入到了阻塞排队序列。就造成了线程阻塞。

## Apache 的多线程高并发模式
优点：支持多线程并发

缺点：阻塞

## What do the terms “CPU bound” and “I/O bound” mean?:
- CPU Bound means the rate at which process progresses is limited by the speed of the CPU.
A task that performs calculations on a small set of numbers, for example multiplying small matrices, is likely to be CPU bound.
A program is CPU bound if it would go faster if the CPU were faster.

- CPU 密集型意味着处理任务的速度是由CPU的速度限制的，一般是计算型的应用，如果CPU运行速度越快，应用程序越快那就是CPU密集型应用。

- I/O Bound means the rate at which a process progresses is limited by the speed of the I/O subsystem.
A task that processes data from disk, for example, counting the number of lines in a file is likely to be I/O bound.
A program is I/O bound if it would go faster if the I/O subsystem was faster.

- I/O 密集型意味着程序运行速率由I/O子系统的速度限制，从硬盘上读写数据或者计算一个文件的行数属于I/O型操作。

## I/O-bound vs CPU-bound in Node.js
https://bytearcher.com/articles/io-vs-cpu-bound/

Bound implies performance bottleneck 
Bound 意味着性能瓶颈

I/O-bound application waits most of the time for network, filesystem and database.
I/O-bound 型应用消耗大量时间在 网络连接、文件系统、数据库读写。

CPU bound
This kind of application leads to trouble in Node.js. If the application spends too much time performing CPU intensive task all other requests are being held up. 
CPU bound 型应用导致Node.js应用出现问题。如果消耗大量时间用于CPU占用率高的任务，那么所有其他请求将会被挂起。

A typical healthy Node.js server application is I/O bound. That is what Node.js was designed for and handles well using the single-threaded event loop. 
一个健康的Node.js服务应该是I/O密集型的，这也是使用单线程的事件循环模型设计的初衷。


