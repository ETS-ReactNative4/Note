> Node.jsÂ® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.

1. Node.js æ˜¯ä¸€ä¸ªåŸºäº Chrome V8 å¼•æ“çš„ JavaScript è¿è¡Œç¯å¢ƒã€‚
2. Node.js ä½¿ç”¨äº†ä¸€ä¸ªäº‹ä»¶é©±åŠ¨ã€éé˜»å¡å¼ I/O çš„æ¨¡å‹ï¼Œä½¿å…¶è½»é‡åˆé«˜æ•ˆã€‚
3. Node.js çš„åŒ…ç®¡ç†å™¨ npmï¼Œæ˜¯å…¨çƒæœ€å¤§çš„å¼€æºåº“ç”Ÿæ€ç³»ç»Ÿã€‚

ä¸ªäººæ„Ÿè§‰ç§° Node ä¸º JavaScript runtime ä¹Ÿä¸æ˜¯å¾ˆå‡†ç¡®ï¼Œå› ä¸º JavaScript é™¤äº† ECMAScript è¿˜åŒ…æ‹¬äº†å…¶åœ¨æµè§ˆå™¨ç«¯çš„å®ç° BOMã€DOMï¼Œè¿™äº›åœ¨ Node ä¸­æ˜¯ä¸å­˜åœ¨çš„ï¼Œå« ERE ä¼šæ›´è´´åˆ‡ä¸€äº›ï¼Œä½†æ˜¯ Node å› ä¸ºè¿è¡Œåœ¨æœåŠ¡å™¨ç«¯ï¼Œè™½ç„¶ç¼ºå¤±çš„ BOMã€DOMï¼Œä½†æ˜¯å¤šäº†å¾ˆå¤šé’ˆå¯¹æœåŠ¡å™¨ç¼–ç¨‹å¸¸ç”¨çš„å°è£…ï¼Œæˆ‘ä»¬æ¥ç®€å•äº†è§£ä¸€ä¸‹ Node çš„ç»„æˆ
1. ECMAScript è§£é‡Šå™¨
2. npmâ€”â€” node package manager
3. CommonJS module systemï¼šNodeJS è¯ç”Ÿåœ¨ JavaScript æ²¡æœ‰å®˜æ–¹æ¨¡å—ç³»ç»Ÿçš„å¹´ä»£ï¼Œåªèƒ½è‡ªå·±åšä¸€ä¸ªè§„èŒƒå¹¶ä¸”å†…ç½®å®ç°ï¼ˆæœ€æ–°çš„å·²ç»å¼€å§‹æ”¯æŒ ES6 modulesï¼‰
4. debuggerï¼šæ–¹ä¾¿å¼€å‘è€…è¿›è¡Œä»£ç è°ƒè¯•
5. fsã€Streamã€httpã€util ç­‰å¸¸ç”¨å†…ç½®æ¨¡å—

* ä»€ä¹ˆæ˜¯é”™è¯¯ä¼˜å…ˆçš„å›è°ƒå‡½æ•°ï¼Ÿ
* å¦‚ä½•é¿å…å›è°ƒåœ°ç‹±ï¼Ÿ
* å¦‚ä½•ç”¨Nodeæ¥ç›‘å¬80ç«¯å£ï¼Ÿ
* ä»€ä¹ˆæ˜¯äº‹ä»¶å¾ªç¯ï¼Ÿ
* å“ªäº›å·¥å…·å¯ä»¥ç”¨æ¥ä¿è¯ä¸€è‡´çš„ç¼–ç¨‹é£æ ¼ï¼Ÿ
* è¿ç®—é”™è¯¯ä¸ç¨‹åºå‘˜é”™è¯¯çš„åŒºåˆ«ï¼Ÿ
* ä½¿ç”¨NPMæœ‰å“ªäº›å¥½å¤„ï¼Ÿ
* ä»€ä¹ˆæ˜¯stubï¼Ÿä¸¾ä¸ªä½¿ç”¨åœºæ™¯ï¼Ÿ
* ä»€ä¹ˆæ˜¯æµ‹è¯•é‡‘å­—å¡”ï¼Ÿå¯¹äºHTTP APIï¼Œå¦‚ä½•åˆ©ç”¨æµ‹è¯•é‡‘å­—å¡”ï¼Ÿ
* ä½ æœ€å–œæ¬¢çš„HTTPæ¡†æ¶ï¼Œå¹¶è¯´æ˜åŸå› ï¼Ÿ
  
## ä»€ä¹ˆæ˜¯é”™è¯¯ä¼˜å…ˆçš„å›è°ƒå‡½æ•°ï¼Ÿ
Node.js çº¦å®šï¼Œå›è°ƒå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¿…é¡»æ˜¯é”™è¯¯å¯¹è±¡errï¼ˆå¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œè¯¥å‚æ•°å°±æ˜¯ nullï¼‰ï¼ŸåŸå› æ˜¯æ‰§è¡Œåˆ†æˆä¸¤æ®µï¼Œåœ¨è¿™ä¸¤æ®µä¹‹é—´æŠ›å‡ºçš„é”™è¯¯ï¼Œç¨‹åºæ— æ³•æ•æ‰ï¼Œåªèƒ½å½“ä½œå‚æ•°ï¼Œä¼ å…¥ç¬¬äºŒæ®µã€‚

é”™è¯¯ä¼˜å…ˆçš„å›è°ƒå‡½æ•°ç”¨äºä¼ é€’é”™è¯¯å’Œæ•°æ®ã€‚ç¬¬ä¸€ä¸ªå‚æ•°å§‹ç»ˆåº”è¯¥æ˜¯ä¸€ä¸ªé”™è¯¯å¯¹è±¡ï¼Œ ç”¨äºæ£€æŸ¥ç¨‹åºæ˜¯å¦å‘ç”Ÿäº†é”™è¯¯ã€‚å…¶ä½™çš„å‚æ•°ç”¨äºä¼ é€’æ•°æ®
```
fs.readFile(filePath, function(err, data) { 
    if (err) { 
        //handle the error 
    } 
    // use the data object 
});
```

## ä»€ä¹ˆæ˜¯äº‹ä»¶å¾ªç¯
Nodeé‡‡ç”¨çš„æ˜¯å•çº¿ç¨‹çš„å¤„ç†æœºåˆ¶ï¼ˆæ‰€æœ‰çš„I/Oè¯·æ±‚éƒ½é‡‡ç”¨éé˜»å¡çš„å·¥ä½œæ–¹å¼ï¼‰ï¼Œè‡³å°‘ä»Node.jså¼€å‘è€…çš„è§’åº¦æ˜¯è¿™æ ·çš„ã€‚ è€Œåœ¨åº•å±‚ï¼ŒNode.jså€ŸåŠ©libuvæ¥ä½œä¸ºæŠ½è±¡å°è£…å±‚ï¼Œ ä»è€Œå±è”½ä¸åŒæ“ä½œç³»ç»Ÿçš„å·®å¼‚ï¼ŒNodeå¯ä»¥å€ŸåŠ©livuvæ¥æ¥å®ç°å¤šçº¿ç¨‹ã€‚ä¸‹å›¾è¡¨ç¤ºäº†Nodeå’Œlibuvçš„å…³ç³»ã€‚


> Node.jsä½¿ç”¨äº‹ä»¶é©±åŠ¨çš„æ¶æ„ï¼Œè®¸å¤šè¿æ¥å¯ä»¥å¹¶è¡Œå¤„ç†ã€‚æ¯ä¸€ä¸ªè¿æ¥éƒ½ä¼šè§¦å‘ä¸€ä¸ªå›è°ƒ,è¿™ä¸ä»Šå¤©ä½¿ç”¨ OS çº¿ç¨‹çš„æ›´å¸¸è§å¹¶å‘æ¨¡å‹å½¢æˆäº†å¯¹æ¯”ã€‚
åŸºäºçº¿ç¨‹çš„ç½‘ç»œæ•ˆç‡ç›¸å¯¹ä½ä¸‹ï¼Œä½¿ç”¨èµ·æ¥éå¸¸å›°éš¾ã€‚æ­¤å¤–ï¼ŒNode.js çš„ç”¨æˆ·ä¸å¿…æ‹…å¿ƒæ­»é”è¿‡ç¨‹ï¼Œå› ä¸ºæ²¡æœ‰é”ã€‚Node ä¸­å‡ ä¹æ²¡æœ‰å‡½æ•°ç›´æ¥æ‰§è¡Œ I/O æ“ä½œï¼Œå› æ­¤è¿›ç¨‹ä»ä¸é˜»å¡ã€‚


æˆ‘çŸ¥é“Node.jsä½¿ç”¨å•çº¿ç¨‹å’Œäº‹ä»¶å¾ªç¯æ¥å¤„ç†è¯·æ±‚ï¼Œä¸€æ¬¡åªå¤„ç†ä¸€ä¸ª(éé˜»å¡)ã€‚ ä½†æ˜¯ï¼Œå¦‚ä½•å·¥ä½œï¼Œè®©æˆ‘ä»¬è¯´10,000ä¸ªå¹¶å‘è¯·æ±‚ã€‚ äº‹ä»¶å¾ªç¯å°†å¤„ç†æ‰€æœ‰è¯·æ±‚ï¼Ÿ è¿™ä¸ä¼šèŠ±å¤ªé•¿æ—¶é—´å—ï¼Ÿ

## å¤šçº¿ç¨‹ç½‘ç»œåº”ç”¨ç¨‹åºå¤„ç†ä¸Šè¿°å·¥ä½œè´Ÿè½½ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
```
request â”€â”€> spawn thread
							â””â”€â”€> wait for database request
										â””â”€â”€> answer request
request â”€â”€> spawn thread
							â””â”€â”€> wait for database request
										â””â”€â”€> answer request
request â”€â”€> spawn thread
							â””â”€â”€> wait for database request
										â””â”€â”€> answer request
```
åœ¨è¿™æ ·åšæ—¶ï¼Œä»–ä»¬å¿…é¡»åˆ†é…ä¸€ä¸ªçº¿ç¨‹æ‰€éœ€çš„å†…å­˜ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªå®Œå…¨ç‹¬ç«‹çš„ç¨‹åºå †æ ˆï¼Œæ¯ä¸ªçº¿ç¨‹ç­‰ã€‚
æ­¤å¤–ï¼Œä»–ä»¬å¿…é¡»å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹è™½ç„¶ä¸åƒå¯åŠ¨ä¸€ä¸ªå®Œæ•´çš„è¿›ç¨‹é‚£ä¹ˆæ˜‚è´µä½†ä»ç„¶ä¸å®Œå…¨å»‰ä»·ã€‚

## å•çº¿ç¨‹äº‹ä»¶å¾ªç¯
æ¯ä¸ªè¯·æ±‚ä»å°†è·å¾—ä¸å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºç›¸åŒçš„CPUæ—¶é—´ï¼Œä½†æˆ‘ä»¬ä¸éœ€è¦å¯åŠ¨çº¿ç¨‹ã€‚æ‰€ä»¥æˆ‘ä»¬è¿™æ ·åšï¼š
```
request â”€â”€> make database request
request â”€â”€> make database request
request â”€â”€> make database request
database request complete â”€â”€> send response
database request complete â”€â”€> send response
database request complete â”€â”€> send response
```
å®é™…ä¸Šï¼Œè¿™ä¸¤ç§æ–¹æ³•éƒ½è¿”å›å¤§è‡´ç›¸åŒå»¶è¿Ÿçš„æ•°æ®ï¼Œå› ä¸ºå®ƒæ˜¯ä¸»å¯¼å¤„ç†çš„æ•°æ®åº“å“åº”æ—¶é—´ã€‚

## [Node.jsç‰¹æ€§](https://nodejs.dev/learn)
A Node.js app is run in a single process, without creating a new thread for every request. 
Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, 
libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.

å¸¸è§„çš„Nodeåº”ç”¨éƒ½æ˜¯ä»¥å•ä¸ªè¿›ç¨‹çš„å½¢å¼è¿è¡Œï¼Œä¸ä¼šä¸ºæ¯ä¸€ä¸ªè¯·æ±‚éƒ½åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ã€å“ªäº›ç¼–ç¨‹è¯­è¨€ä¼šä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºçº¿ç¨‹ï¼Ÿã€‘ã€‚
Node.jsåœ¨å…¶æ ‡å‡†åº“ä¸­æä¾›äº†å¤§é‡çš„å¼‚æ­¥çš„æ–¹æ³•æ¥é¿å…jsä»£ç åœ¨è¿è¡Œæ—¶å‘ç”Ÿé˜»å¡ã€å¦‚æœä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼ˆäº‹ä»¶è½®è¯¢çº¿ç¨‹ï¼‰æˆ–è€…ä»»åŠ¡ï¼ˆå·¥ä½œçº¿ç¨‹ï¼‰éœ€è¦è€—è´¹å¾ˆé•¿æ—¶é—´ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œé˜»å¡â€ã€‚ 
å½“ä¸€ä¸ªçº¿ç¨‹åœ¨å¤„ç†æŸä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚æ—¶è¢«é˜»å¡äº†ï¼Œå®ƒå°±æ— æ³•å¤„ç†å…¶å®ƒå®¢æˆ·ç«¯çš„è¯·æ±‚äº†ã€‚

When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.

å½“Node.jsæ‰§è¡ŒI/Oæ“ä½œã€è¯»å–ç½‘ç»œè¯·æ±‚ï¼Œå­˜å–æ•°æ®åº“æˆ–è€…æ–‡ä»¶ç³»ç»Ÿã€‘ï¼Œå®ƒçš„å¤„ç†æ–¹å¼éƒ½ä¸ä¼šé˜»å¡çº¿ç¨‹é€ æˆCPUç­‰å¾…ï¼Œå®ƒæ˜¯ä¼šç­‰å¼‚æ­¥æ“ä½œè¿”å›æ‰§è¡Œç»“æœç„¶åæ¢å¤ä¹‹å‰çš„æ“ä½œ.

JavaScriptå¦‚æœé˜»å¡äº†é‚£å°±æ˜¯å‡ºç°äº†å¼‚å¸¸ï¼Œè¿™ä¹Ÿå°±æ˜¯å®ƒä¸ºä»€ä¹ˆä¼šåŸºäºé‚£ä¹ˆå¤šçš„å›è°ƒå‡½æ•°ï¼ŒåŒ…æ‹¬åæ¥å‡ºç°çš„promiseå’Œasync/awaitã€å›è°ƒå‡½æ•°æ˜¯å¦‚ä½•é¿å…äº†é˜»å¡ï¼Ÿã€‘

This allows Node.js to handle thousands of concurrent connections with a single server without introducing the burden of managing thread concurrencyï¼Œwhich could be a significant source of bugs
è¿™å°±å…è®¸Node.jså•ä¸ªæœåŠ¡å°±å¯ä»¥å¤„ç†å¤§é‡çš„å¹¶å‘è¿æ¥, è€Œä¸ç”¨è€ƒè™‘ç”¨å¤šçº¿ç¨‹æ¥å¤„ç†å¹¶å‘ã€å“ªäº›è¯­è¨€åœ¨ç”¨å¤šçº¿ç¨‹å¤„ç†å¹¶å‘ï¼Ÿæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿã€‘


[Don't block event loop](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/)

Node.js æœ‰ä¸¤ç§ç±»å‹çš„çº¿ç¨‹ï¼šä¸€ä¸ªäº‹ä»¶å¾ªç¯çº¿ç¨‹å’Œ k ä¸ªå·¥ä½œçº¿ç¨‹ã€‚ 
äº‹ä»¶å¾ªç¯è´Ÿè´£ JavaScript å›è°ƒå’Œéé˜»å¡ I/Oï¼Œå·¥ä½œçº¿ç¨‹æ‰§è¡Œä¸ C++ ä»£ç å¯¹åº”çš„ã€å®Œæˆå¼‚æ­¥è¯·æ±‚çš„ä»»åŠ¡ï¼ŒåŒ…æ‹¬é˜»å¡ I/O å’Œ CPU å¯†é›†å‹å·¥ä½œã€‚ 
è¿™ä¸¤ç§ç±»å‹çš„çº¿ç¨‹ä¸€æ¬¡éƒ½åªèƒ½å¤„ç†ä¸€ä¸ªæ´»åŠ¨ã€‚ å¦‚æœä»»æ„ä¸€ä¸ªå›è°ƒæˆ–ä»»åŠ¡éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œåˆ™è¿è¡Œå®ƒçš„çº¿ç¨‹å°†è¢« é˜»å¡ã€‚ å¦‚æœä½ çš„åº”ç”¨ç¨‹åºå‘èµ·é˜»å¡çš„å›è°ƒæˆ–ä»»åŠ¡ï¼Œåœ¨å¥½çš„æƒ…å†µä¸‹è¿™å¯èƒ½åªä¼šå¯¼è‡´ååé‡ä¸‹é™ï¼ˆå®¢æˆ·ç«¯/ç§’ï¼‰ï¼Œè€Œåœ¨æœ€åæƒ…å†µä¸‹å¯èƒ½ä¼šå¯¼è‡´å®Œå…¨æ‹’ç»æœåŠ¡ã€‚

è¦ç¼–å†™é«˜ååé‡ã€é˜² DoS æ”»å‡»çš„ web æœåŠ¡ï¼Œæ‚¨å¿…é¡»ç¡®ä¿ä¸ç®¡åœ¨è‰¯æ€§æˆ–æ¶æ„è¾“å…¥çš„æƒ…å†µä¸‹ï¼Œæ‚¨çš„äº‹ä»¶å¾ªç¯çº¿ç¨‹å’Œæ‚¨çš„å·¥ä½œçº¿ç¨‹éƒ½ä¸ä¼šé˜»å¡ã€‚

è¯·è®°ä½ï¼Œäº‹ä»¶å¾ªç¯çº¿ç¨‹åªè´Ÿè´£åè°ƒå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œè€Œä¸æ˜¯ç‹¬è‡ªæ‰§è¡Œå®Œæ‰€æœ‰ä»»åŠ¡ã€‚ å¯¹ä¸€ä¸ªå¤æ‚çš„ä»»åŠ¡ï¼Œæœ€å¥½æŠŠå®ƒä»äº‹ä»¶å¾ªç¯çº¿ç¨‹è½¬ç§»åˆ°å·¥ä½œçº¿ç¨‹æ± ä¸Šã€‚

> å…·ä½“event loopå¦‚ä½•å·¥ä½œï¼ŒæŸ¥çœ‹[**libuv**](./libuv.md)

## [ä¸è¦é˜»å¡ä½ çš„äº‹ä»¶å¾ªç¯ï¼ˆæˆ–æ˜¯å·¥ä½œçº¿ç¨‹æ± ï¼‰](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/)

Node.js æ˜¯ç”¨å¾ˆå°‘é‡çš„çº¿ç¨‹æ¥å¤„ç†å¤§é‡å®¢æˆ·ç«¯è¯·æ±‚çš„ã€‚ åœ¨ Node.js ä¸­ï¼Œæœ‰ä¸¤ç§ç±»å‹çš„çº¿ç¨‹ï¼šä¸€ä¸ªäº‹ä»¶å¾ªç¯çº¿ç¨‹ï¼ˆä¹Ÿè¢«ç§°ä¸ºä¸»å¾ªç¯ï¼Œä¸»çº¿ç¨‹ï¼Œäº‹ä»¶çº¿ç¨‹ç­‰ï¼‰ã€‚
å¦å¤–ä¸€ä¸ªæ˜¯åœ¨å·¥ä½œçº¿ç¨‹æ± é‡Œçš„ k ä¸ªå·¥ä½œçº¿ç¨‹ï¼ˆä¹Ÿè¢«ç§°ä¸ºçº¿ç¨‹æ± ï¼‰ã€‚

è¯·è®°ä½ï¼Œäº‹ä»¶å¾ªç¯çº¿ç¨‹åªè´Ÿè´£åè°ƒå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œè€Œä¸æ˜¯ç‹¬è‡ªæ‰§è¡Œå®Œæ‰€æœ‰ä»»åŠ¡ã€‚ å¯¹ä¸€ä¸ªå¤æ‚çš„ä»»åŠ¡ï¼Œæœ€å¥½æŠŠå®ƒä»äº‹ä»¶å¾ªç¯çº¿ç¨‹è½¬ç§»åˆ°å·¥ä½œçº¿ç¨‹æ± ä¸Šã€‚

### é˜»å¡
å¦‚æœä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼ˆäº‹ä»¶è½®è¯¢çº¿ç¨‹ï¼‰æˆ–è€…ä»»åŠ¡ï¼ˆå·¥ä½œçº¿ç¨‹ï¼‰éœ€è¦è€—è´¹å¾ˆé•¿æ—¶é—´ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œé˜»å¡â€ã€‚ å½“ä¸€ä¸ªçº¿ç¨‹åœ¨å¤„ç†æŸä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚æ—¶è¢«é˜»å¡äº†ï¼Œå®ƒå°±æ— æ³•å¤„ç†å…¶å®ƒå®¢æˆ·ç«¯çš„è¯·æ±‚äº†ã€‚ è¿™é‡Œç»™å‡ºä¸¤ä¸ªä¸èƒ½é˜»å¡äº‹ä»¶è½®è¯¢çº¿ç¨‹å’Œå·¥ä½œçº¿ç¨‹çš„ç†ç”±ï¼š

- æ€§èƒ½ï¼šå¦‚æœä½ åœ¨ä»»æ„ç±»å‹çš„çº¿ç¨‹ä¸Šé¢‘ç¹å¤„ç†ç¹é‡çš„ä»»åŠ¡ï¼Œé‚£ä¹ˆä½ çš„æœåŠ¡å™¨çš„ ååé‡ï¼ˆè¯·æ±‚/ç§’ï¼‰å°†é¢ä¸´ä¸¥å³»è€ƒéªŒã€‚
- å®‰å…¨æ€§ï¼šå¦‚æœå¯¹äºç‰¹å®šçš„è¾“å…¥ï¼Œä½ çš„æŸç§ç±»å‹çš„çº¿ç¨‹å¯èƒ½ä¼šè¢«é˜»å¡ï¼Œé‚£ä¹ˆæ¶æ„æ”»å‡»è€…å¯ä»¥é€šè¿‡æ„é€ ç±»ä¼¼è¿™æ ·çš„â€œæ¶æ„è¾“å…¥â€ï¼Œæ•…æ„è®©ä½ çš„çº¿ç¨‹é˜»å¡ï¼Œç„¶åä½¿å…¶å®ƒå®¢æˆ·ç«¯è¯·æ±‚å¾—ä¸åˆ°å¤„ç†ã€‚è¿™å°±æ˜¯æ‹’ç»æœåŠ¡æ”»å‡»ã€‚


## NodeJS ä½¿ç”¨åœºæ™¯

ä¼˜ç‚¹ï¼šé«˜å¹¶å‘ï¼ˆæœ€é‡è¦çš„ä¼˜ç‚¹ï¼‰ã€é€‚åˆ I/O å¯†é›†å‹åº”ç”¨
```
å½“ä½ è¯´Node.JSå¯ä»¥å¤„ç†10,000ä¸ªå¹¶å‘è¯·æ±‚æ—¶ï¼Œå®ƒä»¬æœ¬è´¨ä¸Šæ˜¯éé˜»å¡è¯·æ±‚ï¼Œå³è¿™äº›è¯·æ±‚ä¸»è¦ä¸æ•°æ®åº“æŸ¥è¯¢æœ‰å…³ã€‚
```

ç¼ºç‚¹ï¼š
1. ä¸é€‚åˆCPUå¯†é›†å‹åº”ç”¨ï¼ˆCPUå¯†é›†å‹åº”ç”¨ç»™Nodeå¸¦æ¥çš„æŒ‘æˆ˜ä¸»è¦æ˜¯ï¼šç”±äºJavaScriptå•çº¿ç¨‹çš„åŸå› ï¼Œå¦‚æœæœ‰é•¿æ—¶é—´è¿è¡Œçš„è®¡ç®—ï¼ˆæ¯”å¦‚å¤§å¾ªç¯ï¼‰ï¼Œ
   å°†ä¼šå¯¼è‡´ CPU æ—¶é—´ç‰‡ä¸èƒ½é‡Šæ”¾ï¼Œä½¿å¾—åç»­ I/O æ— æ³•å‘èµ·ï¼‰

è§£å†³æ–¹æ¡ˆï¼šè¿™ä¸ªä¸æ˜¯æ­£ç¡®çš„è§’åº¦ï¼ï¼ï¼ è¿™é‡Œæ˜¯è¦è§£å†³CPUå¯†é›†å‹çš„é—®é¢˜ï¼Œéœ€è¦æŠŠCPUå¯†é›†å‹ä»»åŠ¡ä»event loopçº¿ç¨‹æ‹¿å‡ºå»
```
ï¼ˆ1ï¼‰Nnigx åå‘ä»£ç†ï¼Œè´Ÿè½½å‡è¡¡ï¼Œå¼€å¤šä¸ªè¿›ç¨‹ï¼Œç»‘å®šå¤šä¸ªç«¯å£ï¼›
ï¼ˆ2ï¼‰å¼€å¤šä¸ªè¿›ç¨‹ç›‘å¬åŒä¸€ä¸ªç«¯å£ï¼Œä½¿ç”¨clusteræ¨¡å—
ï¼ˆ3ï¼‰çº¿ä¸Šä½¿ç”¨ PM2 ç®¡ç†è¿›ç¨‹ï¼Œå‡ºç°é—®é¢˜è‡ªåŠ¨é‡å¯é¡¹ç›®
```

å¯ä»¥ä½¿ç”¨Node.js çš„child process,  worker_thread
é‚£ä¹ˆå“ªç§ç¼–ç¨‹è¯­è¨€å¯ä»¥ç”¨ä»€ä¹ˆæ ·çš„æ–¹å¼æ¯”è¾ƒå¥½çš„å¤„ç†CPUå¯†é›†å‹çš„æƒ…æ™¯ï¼Ÿ


## å„ç§ç¼–ç¨‹è¯­è¨€å¤„ç†å¹¶å‘çš„æ–¹å¼
[What makes the Single Threaded Event Loop Model Efficient?](https://blog.soshace.com/advanced-node-js-a-hands-on-guide-to-event-loop-child-process-and-worker-threads-in-node-js/)

To better understand what problem Node.js solves we should look at the what typical web servers were like before Node.js came into play.

This is how a traditional multi-threaded web application model handles request:

- It maintains a thread pool (a collection of available threads)
- When client request comes in a thread is assigned
- This thread will take care of reading Client requests, processing Client requestS, performing any Blocking IO Operations (if required) and preparing Response.
- This thread is not free until a response is sent back

è¿™ç§æ¨¡å‹æœ€å¤§çš„ç¼ºç‚¹å°±æ˜¯æœ‰å¤§é‡å¹¶å‘è¿æ¥çš„æ—¶å€™çº¿ç¨‹æ¯ç«­ï¼Œåæ¥çš„ç”¨æˆ·éœ€è¦ç­‰å¾…å‰è¾¹ç”¨æˆ·çš„çº¿ç¨‹é‡Šæ”¾è¿›è€Œè·å¾—å“åº”ã€‚
Moreover, the server itself start to slow down because of increasing load. Thereâ€™s also the overhead of context switching between threads and writing applications to optimize threads resource sharing can be painful.

What happens when you run a Node.js Program?
when we run our Node.js app it creates

1. Process ğŸ¤–
2. Thread ğŸ§µ
3. Event Loop â°

The single-threaded event loop architecture uses resources efficiently,
it doesnâ€™t need to spin off new threads for every single request.Node.js also delegates blocking tasks to other components as we saw earlier. Since we donâ€™t really care about many threads it makes node.js very lightweight and ideal for microservice-based architecture.
![event loop](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-2-1.jpg)

### Drawbacks of Nodeâ€™s Single Threaded Model !!!
This is 2020 ğŸ˜„ and we are seeing more and more complicated web applications. What if our application needs to do complex computation, run a machine learning algorithm? Or What if we want to run a complicated crypto algorithm? In this case we have to harness the power of multiple cores to increase performance.

Languages like Java and C# can programmatically initiate threads and harness the power of multiple cores. In Node.js that is not an option as we saw earlier. Nodeâ€™s way of solving this problem is child_process.
![child](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-3-1.jpg)

In 2018 Node.js introduced worker_thread. This module allows node the ability to have

1. Process
Multiple threads
2. Event Loop per thread
Yes!! You read that right ğŸ˜„.

![worker](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-4-1.jpg)

As of January 2020 worker_threads are fully supported in the Node LST version 12. I highly recommend reading up the following post if you want to learn more about worker_threads.

[Node.js multithreading](https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/)

### Node.js
["I/O" ä¸»è¦æŒ‡ç”±libuvæ”¯æŒçš„ï¼Œä¸ç³»ç»Ÿç£ç›˜å’Œç½‘ç»œä¹‹é—´çš„äº¤äº’](https://nodejs.org/zh-cn/docs/guides/blocking-vs-non-blocking/)
libuv - Cross-platform asynchronous I/O 

- Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
- Asynchronous file and file system operations
- IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
- Child processes


### java

### Golang

## Apache çš„å¤šçº¿ç¨‹é«˜å¹¶å‘æ¨¡å¼
ä¼˜ç‚¹ï¼šæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘

ç¼ºç‚¹ï¼šé˜»å¡


## é™„å½•
### What do the terms â€œCPU boundâ€ and â€œI/O boundâ€ mean?:
- CPU Bound means the rate at which process progresses is limited by the speed of the CPU.
A task that performs calculations on a small set of numbers, for example multiplying small matrices, is likely to be CPU bound.
A program is CPU bound if it would go faster if the CPU were faster.

- CPU å¯†é›†å‹æ„å‘³ç€å¤„ç†ä»»åŠ¡çš„é€Ÿåº¦æ˜¯ç”±CPUçš„é€Ÿåº¦é™åˆ¶çš„ï¼Œä¸€èˆ¬æ˜¯è®¡ç®—å‹çš„åº”ç”¨ï¼Œå¦‚æœCPUè¿è¡Œé€Ÿåº¦è¶Šå¿«ï¼Œåº”ç”¨ç¨‹åºè¶Šå¿«é‚£å°±æ˜¯CPUå¯†é›†å‹åº”ç”¨ã€‚

- I/O Bound means the rate at which a process progresses is limited by the speed of the I/O subsystem.
A task that processes data from disk, for example, counting the number of lines in a file is likely to be I/O bound.
A program is I/O bound if it would go faster if the I/O subsystem was faster.

- I/O å¯†é›†å‹æ„å‘³ç€ç¨‹åºè¿è¡Œé€Ÿç‡ç”±I/Oå­ç³»ç»Ÿçš„é€Ÿåº¦é™åˆ¶ï¼Œä»ç¡¬ç›˜ä¸Šè¯»å†™æ•°æ®æˆ–è€…è®¡ç®—ä¸€ä¸ªæ–‡ä»¶çš„è¡Œæ•°å±äºI/Oå‹æ“ä½œã€‚

### I/O-bound vs CPU-bound in Node.js
https://bytearcher.com/articles/io-vs-cpu-bound/

Bound implies performance bottleneck 
Bound æ„å‘³ç€æ€§èƒ½ç“¶é¢ˆ

I/O-bound application waits most of the time for network, filesystem and database.
I/O-bound å‹åº”ç”¨æ¶ˆè€—å¤§é‡æ—¶é—´åœ¨ ç½‘ç»œè¿æ¥ã€æ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“è¯»å†™ã€‚

CPU bound
This kind of application leads to trouble in Node.js. If the application spends too much time performing CPU intensive task all other requests are being held up. 
CPU bound å‹åº”ç”¨å¯¼è‡´Node.jsåº”ç”¨å‡ºç°é—®é¢˜ã€‚å¦‚æœæ¶ˆè€—å¤§é‡æ—¶é—´ç”¨äºCPUå ç”¨ç‡é«˜çš„ä»»åŠ¡ï¼Œé‚£ä¹ˆæ‰€æœ‰å…¶ä»–è¯·æ±‚å°†ä¼šè¢«æŒ‚èµ·ã€‚

A typical healthy Node.js server application is I/O bound. That is what Node.js was designed for and handles well using the single-threaded event loop. 
ä¸€ä¸ªå¥åº·çš„Node.jsæœåŠ¡åº”è¯¥æ˜¯I/Oå¯†é›†å‹çš„ï¼Œè¿™ä¹Ÿæ˜¯ä½¿ç”¨å•çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯æ¨¡å‹è®¾è®¡çš„åˆè¡·ã€‚




