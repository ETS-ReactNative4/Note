> Node.js使用事件驱动的架构，许多连接可以并行处理。每一个连接都会触发一个回调,这与今天使用 OS 线程的更常见并发模型形成了对比。
> 基于线程的网络效率相对低下，使用起来非常困难。此外，Node.js 的用户不必担心死锁过程，因为没有锁。Node 中几乎没有函数直接执行 I/O 操作，因此进程从不阻塞。

https://www.codenong.com/34855352/
我知道Node.js使用单线程和事件循环来处理请求，一次只处理一个(非阻塞)。 但是，如何工作，让我们说10,000个并发请求。 事件循环将处理所有请求？ 这不会花太长时间吗？

我无法理解它是如何比多线程Web服务器更快的。 我知道多线程Web服务器的资源(内存，CPU)会更加昂贵，但它不会更快吗？ 我可能错了; 请解释这个单线程如何在大量请求中更快，以及在处理大量请求(例如10,000)时它通常会做什么(在高级别)。

- 多线程网络应用程序处理上述工作负载，如下所示：
	```
	request ──> spawn thread
								└──> wait for database request
											└──> answer request
	request ──> spawn thread
								└──> wait for database request
											└──> answer request
	request ──> spawn thread
								└──> wait for database request
											└──> answer request
	```
因此，线程花费大部分时间使用0％CPU等待数据库返回数据。在这样做时，他们必须分配一个线程所需的内存，其中包含一个完全独立的程序堆栈，每个线程等。
此外，他们必须启动一个线程虽然不像启动一个完整的进程那么昂贵但仍然不完全廉价。

- 单线程事件循环
每个请求仍将获得与多线程应用程序相同的CPU时间，但我们不需要启动线程。所以我们这样做：
	```
	request ──> make database request
	request ──> make database request
	request ──> make database request
	database request complete ──> send response
	database request complete ──> send response
	database request complete ──> send response
	```
实际上，这两种方法都返回大致相同延迟的数据，因为它是主导处理的数据库响应时间。

这里的主要优点是我们不需要生成一个新线程，所以我们不需要做很多很多malloc，这会减慢我们的速度。

## [Node.js特性]https://nodejs.dev/learn
A Node.js app is run in a single process, without creating a new thread for every request. 
Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, 
libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.

常规的Node应用都是以单个进程的形式运行，不会为每一个请求都创建一个线程【哪些编程语言会为每个请求创建线程？】。
Node.js在其标准库中提供了大量的异步的方法来避免js代码在运行时发生阻塞【如果一个线程执行一个回调函数（事件轮询线程）或者任务（工作线程）需要耗费很长时间，我们称之为“阻塞”。 
当一个线程在处理某一个客户端请求时被阻塞了，它就无法处理其它客户端的请求了。】
【这些库都遵循非阻塞的范式】使阻塞行为成为异常而不是常态

When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, 
instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.

当Node.js执行I/O操作【读取网络请求，存取数据库或者文件系统】，它的处理方式都不会阻塞线程造成CPU等待，它是会等异步操作返回执行结果然后恢复之前的操作。【如何实现？- 回调函数】

Being blocking is the exception, and this is why JavaScript is based so much on callbacks, and more recently on promises and async/await.

JavaScript如果阻塞了那就是出现了异常，这也就是它为什么会基于那么多的回调函数，包括后来出现的promise和async/await【回调函数是如何避免了阻塞？】

This allows Node.js to handle thousands of concurrent connections with a single server without introducing the burden of managing thread concurrency， 
which could be a significant source of bugs

这就允许Node.js单个服务就可以处理大量的并发连接, 而不用考虑用多线程来处理并发【哪些语言在用多线程处理并发？有什么问题？】


[Don't block event loop](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/)

Node.js 有两种类型的线程：一个事件循环线程和 k 个工作线程。 
事件循环负责 JavaScript 回调和非阻塞 I/O，工作线程执行与 C++ 代码对应的、完成异步请求的任务，包括阻塞 I/O 和 CPU 密集型工作。 
这两种类型的线程一次都只能处理一个活动。 如果任意一个回调或任务需要很长时间，则运行它的线程将被 阻塞。 如果你的应用程序发起阻塞的回调或任务，在好的情况下这可能只会导致吞吐量下降（客户端/秒），而在最坏情况下可能会导致完全拒绝服务。

要编写高吞吐量、防 DoS 攻击的 web 服务，您必须确保不管在良性或恶意输入的情况下，您的事件循环线程和您的工作线程都不会阻塞。


请记住，事件循环线程只负责协调客户端的请求，而不是独自执行完所有任务。 对一个复杂的任务，最好把它从事件循环线程转移到工作线程池上。


## NodeJS 使用场景

优点：高并发（最重要的优点）、适合 I/O 密集型应用
```
当你说Node.JS可以处理10,000个并发请求时，它们本质上是非阻塞请求，即这些请求主要与数据库查询有关。


```

缺点：
1. 不适合CPU密集型应用（CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），
   将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起）

解决方案：
```
（1）Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口；
（2）开多个进程监听同一个端口，使用cluster模块
（3）线上使用 PM2 管理进程，出现问题自动重启项目
```
那么哪种编程语言可以用什么样的方式比较好的处理CPU密集型的情景？



## 各种编程语言处理并发的方式
### Node.js
["I/O" 主要指由libuv支持的，与系统磁盘和网络之间的交互](https://nodejs.org/zh-cn/docs/guides/blocking-vs-non-blocking/)
libuv - Cross-platform asynchronous I/O 

- Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
- Asynchronous file and file system operations
- IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
- Child processes

#### event loop
The event loop is the central part of libuv’s functionality. 
It takes care of polling for i/o and scheduling callbacks to be run based on different sources of events.
事件循环是libuv的核心功能。它负责处理i/o轮询，调度不同事件的回调函数。
![Design overview](http://docs.libuv.org/en/v1.x/_images/architecture.png)

http://docs.libuv.org/en/v1.x/design.html


### java

### Golang

## Apache 的多线程高并发模式
优点：支持多线程并发

缺点：阻塞


## 附录
### What do the terms “CPU bound” and “I/O bound” mean?:
- CPU Bound means the rate at which process progresses is limited by the speed of the CPU.
A task that performs calculations on a small set of numbers, for example multiplying small matrices, is likely to be CPU bound.
A program is CPU bound if it would go faster if the CPU were faster.

- CPU 密集型意味着处理任务的速度是由CPU的速度限制的，一般是计算型的应用，如果CPU运行速度越快，应用程序越快那就是CPU密集型应用。

- I/O Bound means the rate at which a process progresses is limited by the speed of the I/O subsystem.
A task that processes data from disk, for example, counting the number of lines in a file is likely to be I/O bound.
A program is I/O bound if it would go faster if the I/O subsystem was faster.

- I/O 密集型意味着程序运行速率由I/O子系统的速度限制，从硬盘上读写数据或者计算一个文件的行数属于I/O型操作。

### I/O-bound vs CPU-bound in Node.js
https://bytearcher.com/articles/io-vs-cpu-bound/

Bound implies performance bottleneck 
Bound 意味着性能瓶颈

I/O-bound application waits most of the time for network, filesystem and database.
I/O-bound 型应用消耗大量时间在 网络连接、文件系统、数据库读写。

CPU bound
This kind of application leads to trouble in Node.js. If the application spends too much time performing CPU intensive task all other requests are being held up. 
CPU bound 型应用导致Node.js应用出现问题。如果消耗大量时间用于CPU占用率高的任务，那么所有其他请求将会被挂起。

A typical healthy Node.js server application is I/O bound. That is what Node.js was designed for and handles well using the single-threaded event loop. 
一个健康的Node.js服务应该是I/O密集型的，这也是使用单线程的事件循环模型设计的初衷。




