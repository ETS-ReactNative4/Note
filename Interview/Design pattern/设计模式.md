> A design pattern provides a general reusable solution for the common problems occurs in software design. 
Design patterns are programming language independent strategies for solving a common problem. That means a design pattern represents an idea, not a particular implementation. By using the design patterns you can make your code more flexible, reusable and maintainable.

一种设计模式提供了可复用的解决方案，针对软件设计中经常出现的问题（都有什么问题？）。

通过使用设计模式，可以使你的代码更加灵活，可复用，可维护。

To find out which pattern to use. You just have to try to understand the design patterns and it’s purposes. Only by then you will be able to pick the right one.

要想知道使用哪种设计模式，你就需要了解每种设计模式和它的目的。这样你才能选一个合适的。

### Singleton Pattern（单例模式）

单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。

```js
class Singleton {
    constructor(name="default name") {
        this.name = name
    }
}

const s1 = new Singleton('s1')
const s2 = new Singleton('s2')
const s3 = new Singleton()

console.log(s1.name) // s1
console.log(s2.name) // s2
console.log(s3.name) // default name
```
很明显，这并不是一个单例模式，每次new出来的都是一个新的实例。让我们稍加改写，只让他new一次就好啦。
```js
class Singleton {
    constructor(name="default name") {
        this.name = name
    }
    static getInstance(name) {
        // 判断是否已经new过1个实例
        if (!Singleton.instance) {
            // 若这个唯一的实例不存在，那么先创建它
            Singleton.instance = new Singleton(name)
        }
        // 如果这个唯一的实例已经存在，则直接返回
        return Singleton.instance
    }
}
const s1 = Singleton.getInstance('s1')
const s2 = Singleton.getInstance('s2')
console.log(s1.name) //s1
console.log(s2.name) // s1
console.log(s1===s2) // true
```
这样不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例了。

总结
- 优点：适用于单一对象，只生成一个对象实例，避免频繁创建和销毁实例，减少内存占用。
- 缺点：不适用动态扩展对象，或需创建多个相似对象的场景。


### Factory Method Pattern（工厂方法模式）

意图
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。
适用性
* 当一个类不知道它所必须创建的对象的类的时候。
* 当一个类希望由它的子类来指定它所创建的对象的时候。
* 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！


## 设计模式的6个基本原则

* 单一职责原则（Single Responsibility Principle）
* 里氏代换原则（Liskov Substitution Principle）
* 依赖倒转原则（Dependence Inversion Principle）
* 接口隔离原则（Interface Segregation Principle）
* 迪米特法则，又称最少知道原则（Demeter Principle）
* 开闭原则（Open Close Principle）


